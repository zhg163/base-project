<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>流式API演示</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css">
    <script src="https://cdn.jsdelivr.net/npm/markdown-it@13.0.1/dist/markdown-it.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <style>
        body {
            padding: 20px;
            background-color: #f5f5f5;
        }

        .chat-container {
            height: 500px;
            overflow-y: auto;
            background-color: white;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid #ddd;
        }

        .message {
            margin-bottom: 10px;
            margin-top: 0;
            /* 确保消息顶部没有边距 */
            padding: 10px;
            border-radius: 5px;
            max-width: 80%;
        }

        .user-message {
            background-color: #d1e7ff;
            margin-left: auto;
            text-align: right;
        }

        .assistant-message {
            background-color: #f0f0f0;
            margin-right: auto;
        }

        .message-container {
            display: flex;
            margin-bottom: 15px;
            max-width: 100%;
        }

        .user-container {
            flex-direction: row;
            align-items: flex-start;
            justify-content: flex-end;
        }

        .user-name-label {
            font-size: 12px;
            color: #555;
            margin-left: 10px;
            padding-top: 10px;
            font-weight: 500;
            white-space: nowrap;
        }

        #errorContainer {
            display: none;
            margin-top: 15px;
        }

        .typing-indicator:after {
            content: "...";
            animation: dots 1.5s steps(5, end) infinite;
        }

        @keyframes dots {

            0%,
            20% {
                content: ".";
            }

            40% {
                content: "..";
            }

            60%,
            100% {
                content: "...";
            }
        }

        #phase2Container {
            display: none;
            margin-top: 15px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
            border: 1px solid #ddd;
        }

        #feedbackBtns {
            margin-top: 10px;
        }

        .role-info {
            margin-bottom: 10px;
            padding: 10px;
            background-color: #e2f2ff;
            border-radius: 5px;
            font-size: 14px;
            border-left: 3px solid #0d6efd;
        }

        .info-panel {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
            border: 1px solid #ddd;
        }

        /* 思考容器样式 */
        .thinking-container {
            background-color: #f5f7f9;
            border-radius: 12px;
            margin: 10px 0;
            overflow: hidden;
            transition: all 0.3s ease;
            border-left: 3px solid #1a73e8;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        .thinking-header {
            padding: 12px 15px;
            background-color: #f0f2f5;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
            color: #555;
        }

        .thinking-title {
            font-weight: 500;
            color: #444;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .thinking-title i {
            color: #1a73e8;
        }

        .thinking-reason {
            font-size: 13px;
            color: #666;
            margin-left: 10px;
            font-style: italic;
        }

        .thinking-toggle {
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            padding: 4px;
            font-size: 14px;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }

        .thinking-toggle:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .thinking-content {
            padding: 15px;
            line-height: 1.6;
            color: #333;
            background-color: #f9fafb;
            border-bottom: 1px solid #eee;
            overflow-x: auto;
            display: block;
            /* Changed from max-height: 0 */
        }

        .thinking-step {
            margin: 8px 0;
            padding: 8px 12px;
            border-left: 2px solid #1a73e8;
            background-color: white;
            border-radius: 0 4px 4px 0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            white-space: pre-wrap;
            overflow-wrap: break-word;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
            position: relative;
            /* 用于定位详情按钮 */
            display: flex;
            /* 使用flex布局 */
            align-items: flex-start;
            /* 顶部对齐 */
        }

        /* DeepSeek风格的思考过程标题 */
        .deepseek-thinking-header {
            padding: 12px 15px;
            background-color: #f5f5f5;
            color: #555;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
            font-weight: normal;
            border-bottom: 1px solid #eaeaea;
        }

        .deepseek-thinking-title {
            font-weight: normal;
            color: #555;
            font-size: 14px;
        }

        .thinking-references {
            padding: 10px 15px;
            background-color: #f5f8ff;
            display: block;
            /* Changed from max-height: 0 */
        }

        .reference-card {
            margin: 10px 0;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            background-color: white;
            transition: transform 0.2s;
            border: 1px solid #eaeef2;
        }

        .reference-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .reference-header {
            padding: 12px 15px;
            background-color: #f0f4f8;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #eaeef2;
        }

        .reference-title {
            font-weight: 600;
            color: #333;
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .reference-score {
            font-size: 12px;
            color: #777;
            margin-right: 10px;
            padding: 2px 6px;
            background-color: #e6f7ff;
            border-radius: 10px;
            white-space: nowrap;
        }

        .reference-toggle {
            background-color: #f5f7fa;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 2px 8px;
            font-size: 12px;
            cursor: pointer;
            color: #555;
            transition: all 0.2s;
        }

        .reference-toggle:hover {
            background-color: #e6f7ff;
            border-color: #1a73e8;
            color: #1a73e8;
        }

        .reference-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease;
            padding: 0 15px;
            background-color: white;
        }

        .reference-content p {
            margin: 12px 0;
            line-height: 1.6;
            color: #333;
        }

        .thinking-summary {
            padding: 12px 15px;
            background-color: #eef2f7;
            color: #555;
            font-size: 14px;
            text-align: center;
            border-top: 1px solid #e0e6ed;
        }

        .thinking-error {
            padding: 12px 15px;
            background-color: #fde8e8;
            color: #e53e3e;
            margin: 10px 0;
            border-radius: 6px;
            border-left: 3px solid #e53e3e;
        }

        .thinking-response-divider {
            height: 2px;
            background: linear-gradient(90deg, rgba(26, 115, 232, 0) 0%, rgba(26, 115, 232, 0.5) 50%, rgba(26, 115, 232, 0) 100%);
            margin: 20px 0;
            position: relative;
        }

        .thinking-response-divider::after {
            content: attr(data-role-name) " 回答";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 0 10px;
            color: #1a73e8;
            font-size: 12px;
            font-weight: 500;
        }

        /* 响应容器样式 */
        .response-container {
            display: flex;
            flex-direction: column;
            margin: 15px 0 25px 0;
            position: relative;
        }

        .response-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: #1a73e8;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: normal;
            margin-right: 12px;
            flex-shrink: 0;
            font-size: 12px;
            text-align: center;
            line-height: 1.2;
            overflow: hidden;
            word-break: break-all;
            padding: 5px;
        }

        .response-content {
            flex: 1;
            padding: 16px;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
            line-height: 1.6;
            color: #333;
            transition: all 0.3s ease;
        }

        .response-content.loading::after {
            content: '▌';
            display: inline-block;
            animation: blink 1s step-end infinite;
        }

        .response-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 10px;
            padding-top: 8px;
            border-top: 1px solid #eee;
        }

        .action-btn {
            background-color: #f5f7fa;
            border: 1px solid #ddd;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 16px;
        }

        .action-btn:hover {
            background-color: #e6f7ff;
            border-color: #1a73e8;
            transform: translateY(-2px);
        }

        .like-btn:hover {
            background-color: #e6fff7;
            border-color: #28a745;
        }

        .dislike-btn:hover {
            background-color: #ffebee;
            border-color: #dc3545;
        }

        .copy-btn:hover {
            background-color: #e6f7ff;
            border-color: #1a73e8;
        }

        .regen-btn:hover {
            background-color: #fff3e0;
            border-color: #ff9800;
        }

        /* Toast notification styles */
        .toast {
            visibility: hidden;
            min-width: 250px;
            background-color: #333;
            color: white;
            text-align: center;
            border-radius: 4px;
            padding: 16px;
            position: fixed;
            z-index: 1000;
            left: 50%;
            transform: translateX(-50%);
            bottom: 30px;
            font-size: 14px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transition: opacity 0.3s, visibility 0.3s;
        }

        .toast.show {
            visibility: visible;
            opacity: 1;
        }

        /* Modal styles for detailed content */
        .text-modal {
            display: none;
            position: fixed;
            z-index: 1001;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.4);
        }

        .text-modal-content {
            background-color: #fefefe;
            margin: 10% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 800px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .text-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
            margin-bottom: 15px;
        }

        .text-modal-title {
            font-weight: 600;
            font-size: 18px;
            color: #333;
        }

        .text-modal-close {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .text-modal-close:hover {
            color: #333;
        }

        .text-modal-body {
            max-height: 60vh;
            overflow-y: auto;
            padding: 10px;
            font-size: 14px;
            line-height: 1.6;
            white-space: pre-wrap;
        }

        .text-modal-footer {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #eee;
            text-align: right;
        }

        /* 自定义滚动条样式 */
        .text-modal-body::-webkit-scrollbar {
            width: 8px;
        }

        .text-modal-body::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        .text-modal-body::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 4px;
        }

        .text-modal-body::-webkit-scrollbar-thumb:hover {
            background: #a1a1a1;
        }

        .reference-detail-btn {
            background: none;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            margin-right: 6px;
            color: #666;
            font-size: 12px;
            transition: all 0.2s;
        }

        .reference-detail-btn:hover {
            background-color: #e6f7ff;
            border-color: #1a73e8;
            color: #1a73e8;
        }

        .role-label {
            font-size: 12px;
            color: #555;
            margin-top: 4px;
            text-align: center;
            font-weight: 500;
            position: absolute;
            width: 100%;
            left: 0;
            bottom: -18px;
        }

        /* 匹配信息区域样式 */
        .match-info-area {
            margin: 15px 0;
            padding: 12px;
            background-color: #e6f7ff;
            border-radius: 8px;
            border: 1px solid #b3e0ff;
        }

        .match-info-title {
            font-weight: 600;
            color: #1a73e8;
            margin-bottom: 8px;
            font-size: 14px;
            display: flex;
            align-items: center;
        }

        .match-info-title::before {
            content: '\f52a';
            /* FontAwesome匹配图标 */
            font-family: 'Font Awesome 6 Free';
            font-weight: 900;
            margin-right: 8px;
            color: #1a73e8;
        }

        .match-info-item {
            margin: 6px 0;
            font-size: 13px;
            color: #333;
            line-height: 1.4;
        }

        .match-role-name {
            font-weight: 600;
            color: #1a73e8;
        }

        .match-score {
            font-weight: 600;
            color: #28a745;
        }

        .match-reason {
            font-style: italic;
            color: #555;
        }

        /* 打字机效果样式，修改之前的typing动画 */
        @keyframes typing {
            from {
                width: 0
            }

            to {
                width: 100%
            }
        }

        @keyframes blink-caret {

            from,
            to {
                border-color: transparent
            }

            50% {
                border-color: #1a73e8
            }
        }

        .thinking-step.typing {
            overflow: hidden;
            white-space: nowrap;
            position: relative;
        }

        .thinking-step.typing .thinking-step-content {
            overflow: hidden;
            white-space: nowrap;
            border-right: 2px solid transparent;
            animation:
                typing 3.5s steps(40, end),
                blink-caret 0.75s step-end infinite;
        }

        /* DeepSeek风格样式 */
        .deepseek-thinking-header {
            padding: 12px 15px;
            background-color: #f5f5f5;
            color: #555;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
            font-weight: normal;
            border-bottom: 1px solid #eaeaea;
        }

        .deepseek-thinking-title {
            font-weight: normal;
            color: #555;
            font-size: 14px;
        }

        .reference-preview {
            padding: 10px 15px;
            font-size: 13px;
            color: #444;
            background-color: #f9f9f9;
            border-radius: 0;
            margin: 0;
            white-space: pre-wrap;
            line-height: 1.5;
            max-height: 150px;
            overflow-y: auto;
            border-bottom: 1px solid #eee;
        }

        .reference-view-btn {
            margin: 0 10px 10px 10px;
            padding: 4px 10px;
            font-size: 12px;
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            color: #555;
        }

        .reference-view-btn:hover {
            background-color: #e6f7ff;
            border-color: #1a73e8;
            color: #1a73e8;
        }

        .waiting-message {
            background-color: #f8f9fa;
            border-left: 4px solid #ffc107;
            padding: 10px 15px;
            margin: 10px 0;
            border-radius: 4px;
            font-size: 14px;
            color: #666;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                opacity: 0.7;
            }

            50% {
                opacity: 1;
            }

            100% {
                opacity: 0.7;
            }
        }

        .waiting-message i {
            margin-right: 8px;
            color: #ffc107;
        }

        /* 添加这些CSS样式确保avatar显示正确 */
        /* 在<style>标签中添加以下样式 */
        .ai-avatar {
            width: 40px;
            height: 40px;
            min-width: 40px;
            background-color: #f0f0f0; /* 改为浅灰色背景 */
            color: #333; /* 改为深色文字 */
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 10px;
            font-size: 14px;
        }

        /* 添加CSS样式 */
        .emotion-tag {
            display: inline-block;
            margin-right: 8px;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
            background-color: #f0f0f0;
        }

        .emotion-信任 { background-color: #e3f2fd; color: #1976d2; }
        .emotion-悲伤 { background-color: #e8f5e9; color: #388e3c; }
        .emotion-愤怒 { background-color: #ffebee; color: #d32f2f; }
        .emotion-责任感 { background-color: #e8eaf6; color: #3f51b5; }

        .action-box {
            font-style: italic;
            color: #666;
            margin: 5px 0;
            padding: 5px 10px;
            background-color: #f9f9f9;
            border-left: 3px solid #ccc;
        }

        /* 添加到CSS样式部分 */
        .event-tags {
            display: flex;
            flex-wrap: nowrap;
            margin-bottom: 10px;
            gap: 5px;
            padding-left: 15px;
        }

        .event-tag {
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
        }

        .role-tag { 
            background-color: #f8f9fa; 
            color: #333; 
        }
        .emotion-tag { background-color: #e8f5e9; color: #388e3c; }
        .thinking-tag { background-color: #fff3e0; color: #f57c00; }

        /* 添加思考中样式，包括换行效果 */
        .thinking-tag {
            background-color: #fff3e0;
            color: #f57c00;
            display: inline-block; /* 改为inline-block使其不换行 */
            margin-right: 10px;
        }

        /* 添加换行线样式 */
        .thinking-divider {
            display: none; /* 隐藏分隔线 */
        }

        /* 添加角色标题样式 */
        .chat-header {
            display: flex;
            align-items: center;
            background-color: transparent; /* 去掉灰色背景 */
            padding: 8px 15px;
            border-bottom: 1px solid #e9ecef;
            margin-bottom: 10px;
            border-radius: 5px 5px 0 0;
        }

        .chat-header-title {
            font-size: 16px;
            font-weight: 500;
            color: #333;
            margin-right: 10px;
        }

        /* 情绪标签样式 - 让它更适合在标题行中显示 */
        .header-emotion-tag {
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
            background-color: #e8f5e9;
            color: #388e3c;
            display: inline-block;
        }

        /* 添加到style标签中 */
        .thinking-content-box { /* 这是思考内容的总容器 */
            font-size: 14px; 
            color: #888; 
            background-color: #f9f9f9;
            padding: 10px 15px;
            margin: 0 0 10px 0; /* thinking-box-header takes care of top margin */
            border-radius: 0 0 8px 8px; /* Rounded bottom corners if header is separate */
            border-left: 3px solid #ffc107;
            line-height: 1.5;
            white-space: pre-wrap;
            overflow-wrap: break-word;
            font-family: monospace;
            max-height: 200px;
            overflow-y: auto;
            /* Ensure the box itself takes full available width if its parent allows */
            width: 100%; /* Or based on its parent in .response-container */
            box-sizing: border-box; /* Important if padding/border are added */
        }

        .thinking-content-box.thinking-completed {
            border-left-color: #28a745;
        }

        .thinking-content-wrapper { /* 包裹所有思考内容块(span + br)的div */
            display: block; /* Default is block, just to be sure */
            width: 100%; /* Ensure this wrapper takes full width of its parent (.thinking-content-box) */
        }

        .typing-text, 
        .rag-knowledge.typing-text { /* Target both normal and RAG thinking texts */
            white-space: pre-wrap;
            overflow-wrap: break-word; 
            display: block; /* 改为块级元素，使其能够占据整行 */
            width: 100%;    /* 宽度撑满其父容器 (.thinking-content-wrapper) */
            box-sizing: border-box; /* 如果未来给这些span加padding/border，这个属性很重要 */
            /* text-align: left; */ /* 默认是left, 如果需要justify则取消注释，但需谨慎 */
        }

        /* 如果 .rag-knowledge 有特定样式，确保它们与 .typing-text 结合时不会冲突 */
        .rag-knowledge { /* This style was already present */
            color: #4a6da7; 
            font-weight: 500;
        }

        .thinking-box-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background-color: #f0f2f5;
            border-radius: 8px 8px 0 0;
            border-left: 3px solid #ffc107;
            margin-top: 10px;
            font-size: 14px;
            color: #666;
            cursor: pointer;
        }

        .thinking-box-toggle {
            background: none;
            border: none;
            cursor: pointer;
            color: #777;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }

        .thinking-box-toggle:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .thinking-content-box {
            font-size: 14px; /* 比正文小2号 */
            color: #888; /* 浅灰色 */
            background-color: #f9f9f9;
            padding: 10px 15px;
            margin: 0 0 10px 0;
            border-radius: 0 0 8px 8px;
            border-left: 3px solid #ffc107;
            line-height: 1.5;
            white-space: pre-wrap;
            overflow-wrap: break-word;
            font-family: monospace;
            max-height: 200px;
            overflow-y: auto;
        }

        .thinking-completed {
            border-left-color: #28a745;
        }

        .thinking-content-wrapper {
            display: block;
        }
    </style>
</head>

<body>
    <!-- 文本弹窗 -->
    <div id="textModal" class="text-modal">
        <div class="text-modal-content">
            <div class="text-modal-header">
                <h4 class="text-modal-title">详细内容</h4>
                <span class="text-modal-close">&times;</span>
            </div>
            <div id="textModalBody" class="text-modal-body"></div>
            <div class="text-modal-footer">
                <button id="textModalUpdateBtn" class="btn btn-primary">更新提示词</button>
                <button id="textModalCloseBtn" class="btn btn-secondary">关闭</button>
            </div>
        </div>
    </div>

    <div class="container">
        <h1 class="mb-4">流式API演示</h1>

        <div class="row">
            <div class="col-md-8">
                <div id="chatContainer" class="chat-container">
                    <!-- 聊天消息将在这里动态添加 -->
                </div>

                <div id="typingIndicator" class="typing-indicator" style="display: none;">AI正在思考</div>

                <div class="mb-3">
                    <label for="userInput" class="form-label">发送消息</label>
                    <textarea id="userInput" class="form-control" rows="3" placeholder="输入您的问题..."></textarea>
                </div>

                <button id="sendBtn" class="btn btn-primary">发送</button>

                <div id="errorContainer" class="alert alert-danger mt-3">
                    <strong>错误：</strong> <span id="errorMessage"></span>
                </div>
            </div>

            <div class="col-md-4">
                <div class="info-panel">
                    <h4>当前会话信息</h4>
                    <div id="sessionInfo">未创建会话</div>
                </div>

                <div class="info-panel mt-3">
                    <h4>角色信息</h4>
                    <div id="roleInfo"></div>
                </div>

                <button id="createSessionBtn" class="btn btn-outline-primary w-100 mb-3">创建会话</button>
                <button id="clearChatBtn" class="btn btn-outline-secondary w-100 mb-3">清空聊天记录</button>

                <div class="form-group mb-3">
                    <label for="apiEndpoint" class="form-label">发送消息地址</label>
                    <select id="apiEndpoint" class="form-select">
                        <option value="/api/llm/chat">普通聊天 (/api/llm/chat)</option>
                        <option value="/api/llm/chatstream" selected>流式聊天 (/api/llm/chatstream)</option>
                        <option value="/api/llm/chatstreamrag">RAG流式聊天 (/api/llm/chatstreamrag)</option>
                    </select>
                </div>

                <div class="form-check mb-3">
                    <input class="form-check-input" type="checkbox" id="showThinking" checked>
                    <label class="form-check-label" for="showThinking">
                        显示AI思考过程
                    </label>
                </div>

                <div class="mt-4 text-center">
                    <a href="/static/session_manager.html"
                        class="btn btn-outline-secondary w-100">返回会话管理</a>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // DOM 元素
            const chatContainer = document.getElementById('chatContainer');
            const userInput = document.getElementById('userInput');
            const sendBtn = document.getElementById('sendBtn');
            const errorContainer = document.getElementById('errorContainer');
            const errorMessage = document.getElementById('errorMessage');
            const sessionInfo = document.getElementById('sessionInfo');
            const roleInfo = document.getElementById('roleInfo');
            const typingIndicator = document.getElementById('typingIndicator');
            const createSessionBtn = document.getElementById('createSessionBtn');
            const clearChatBtn = document.getElementById('clearChatBtn');
            const apiEndpoint = document.getElementById('apiEndpoint');

            // 状态变量
            let currentSessionId = null;
            let lastMessageId = null;
            let currentEventSource = null;
            let currentUserName = "用户"; // 默认用户名
            let markdownEnabled = false; // 是否启用Markdown渲染
            let lastUserMessage = null; // 最后一条用户消息
            let currentFeedbackMessageId = null; // 当前反馈消息ID
            let currentFeedbackState = 'pending'; // 当前反馈状态
            let currentRole = null; // 添加当前角色变量初始化

            let currentThinkingContainer = null;
            let currentResponseContainer = null;
            let isThinking = false;
            let thinkingStep = '';
            let responseContent = '';
            let typewriterInterval = null;
            let typingSpeed = 15; // ms per character

            let isProcessingMessage = false; // 标记是否正在处理消息
            let lastSentMessage = ""; // 记录最后发送的消息内容
            let lastSentTime = 0; // 记录最后发送消息的时间
            let currentThinkingMode = false;
            let responseContainer = null;
            let messageTimeout; // Add timeout variable for safety
            let currentActiveResponseContainer = null; // ADD THIS LINE

            // 添加全局变量用于存储上一次的完整消息
            let previousFullMessage = '';
            let currentCleanedContentForDisplay = ''; // ADDED: Tracks accumulated cleaned final response
            let typingTimer = null;
            let currentTypingIndex = 0;
            let pendingText = '';

            // 添加全局变量用于存储思考内容
            let isThinkingCompleted = false;
            // 全局的状态变量，确保在每次新消息开始时重置
            let isResponseStarted = false; // This is fine at global scope if reset correctly per message cycle

            // 解析URL参数函数
            function getUrlParams() {
                const params = {};
                const queryString = window.location.search;
                const urlParams = new URLSearchParams(queryString);

                for (const [key, value] of urlParams.entries()) {
                    params[key] = value;
                }

                return params;
            }

            // 修改processUrlParams函数，使其能正确处理和显示URL参数
            function processUrlParams() {
                const params = getUrlParams();

                if (params.session_id) {
                    currentSessionId = params.session_id;

                    // 更新会话信息显示，包含更多用户信息
                    sessionInfo.innerHTML = `
                        <strong>会话ID:</strong> ${currentSessionId.substring(0, 8)}...<br>
                        <strong>用户:</strong> ${params.userName || '未知用户'}<br>
                        <strong>用户ID:</strong> ${params.userId || '未知ID'}<br>
                        <strong>来源:</strong> URL参数
                    `;

                    // 获取会话角色信息
                    fetchSessionRoles(currentSessionId);

                    // 禁用创建会话按钮
                    createSessionBtn.textContent = "已加载会话";
                    createSessionBtn.disabled = true;

                    // 显示参数（如果displayParams=true）
                    if (params.displayParams === 'true') {
                        console.log('URL参数:', params);
                    }

                    // 更新当前用户名
                    if (params.userName) {
                        currentUserName = params.userName;
                    }

                    return true;
                }

                return false;
            }

            // 修改fetchSessionRoles函数，确保正确获取角色信息
            async function fetchSessionRoles(sessionId) {
                try {
                    // 显示加载状态
                    roleInfo.innerHTML = '<div class="text-center"><div class="spinner-border text-primary" role="status"></div><p>正在加载角色信息...</p></div>';

                    // 获取会话详情
                    const response = await fetch(`/api/custom-sessions/${sessionId}`);
                    if (!response.ok) {
                        throw new Error('获取会话详情失败');
                    }

                    const sessionData = await response.json();
                    console.log('会话详情:', sessionData);

                    // 检查是否有角色数据
                    if (sessionData.roles && sessionData.roles.length > 0) {
                        // 更新角色信息显示
                        roleInfo.innerHTML = sessionData.roles.map((role, index) => `
                            <div class="role-info">
                                <strong>${role.role_name || '未命名角色'}</strong><br>
                                <small class="text-muted">角色ID: ${role.role_id}</small><br>
                                ${role.system_prompt ?
                                `<div class="small mt-2 text-expandable" style="max-height: 150px; overflow-y: auto; background-color: #f8f9fa; padding: 8px; border-radius: 4px; font-family: monospace;" data-content="${encodeURIComponent(role.system_prompt)}" data-title="${encodeURIComponent(role.role_name || '未命名角色')} 的系统提示词" data-role-id="${role.role_id}" data-role-index="${index}">${role.system_prompt}</div>`
                                : '<small class="text-muted">无系统提示词</small>'}
                            </div>
                        `).join('');
                    } else {
                        // 如果没有找到角色信息
                        roleInfo.innerHTML = '<div class="alert alert-warning">未找到角色信息</div>';

                        // 尝试获取角色列表作为备选方案
                        fetchRoleList();
                    }
                } catch (error) {
                    console.error('获取会话角色信息失败:', error);
                    roleInfo.innerHTML = `<div class="alert alert-danger">获取角色信息失败: ${error.message}</div>`;

                    // 尝试获取角色列表作为备选方案
                    fetchRoleList();
                }
            }

            // 获取角色列表（备选方案）
            async function fetchRoleList() {
                try {
                    const response = await fetch('/api/roles/?limit=5');
                    if (!response.ok) {
                        throw new Error('获取角色列表失败');
                    }

                    const roles = await response.json();
                    if (roles && roles.length > 0) {
                        roleInfo.innerHTML = `
                            <div class="alert alert-info mb-3">未找到会话关联角色，显示系统角色列表：</div>
                            ${roles.map(role => `
                            <div class="role-info">
                                <strong>${role.name || '未命名角色'}</strong><br>
                                <small class="text-muted">角色ID: ${role._id}</small><br>
                                ${role.system_prompt ?
                                `<div class="small mt-2 text-expandable" style="max-height: 150px; overflow-y: auto; background-color: #f8f9fa; padding: 8px; border-radius: 4px; font-family: monospace;" data-content="${encodeURIComponent(role.system_prompt)}" data-title="${encodeURIComponent(role.name || '未命名角色')} 的系统提示词">${role.system_prompt}</div>`
                                : '<small class="text-muted">无系统提示词</small>'}
                            </div>
                            `).join('')}
                        `;
                    }
                } catch (error) {
                    console.error('获取角色列表失败:', error);
                    // 已经显示了错误，不再添加新错误
                }
            }

            // 更新当前角色显示
            function updateCurrentRoleDisplay() {
                if (!currentRole) return;

                // 更新角色信息区域
                const roleInfoElement = document.getElementById('roleInfo');

                if (roleInfoElement) {
                    roleInfoElement.innerHTML = `
                        <div class="role-info">
                            <strong>当前角色: ${currentRole.name}</strong>
                            <div>ID: ${currentRole.id}</div>
                        </div>
                    `;
                }
            }

            // 初始化，创建一个新会话
            async function createSession() {
                try {
                    // 禁用按钮
                    createSessionBtn.disabled = true;
                    createSessionBtn.textContent = '创建中...';

                    // 构造请求数据
                    const data = {
                        user_id: getUrlParams().userId || 'anonymous',
                        user_name: getUrlParams().userName || '用户'
                    };

                    // 发送POST请求创建会话
                    const response = await fetch('/api/sessions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(data)
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const result = await response.json();

                    // 更新会话信息
                    currentSessionId = result.session_id;
                    document.getElementById('sessionInfo').textContent = `会话ID: ${currentSessionId}`;

                    // 显示成功提示
                    showToast('会话创建成功');

                    // 加载会话角色
                    fetchSessionRoles(currentSessionId);

                } catch (error) {
                    console.error('创建会话失败:', error);
                    handleError(`创建会话失败: ${error.message}`);

                    // 重置按钮状态
                    createSessionBtn.disabled = false;
                    createSessionBtn.textContent = '创建会话';
                }
            }

            // 显示用户消息
            function addUserMessage(message) {
                if (!message) return;

                // 创建消息容器
                const messageContainer = document.createElement('div');
                messageContainer.className = 'message-container user-container';

                // 创建消息元素
                const messageElement = document.createElement('div');
                messageElement.className = 'message user-message';
                messageElement.textContent = message;

                // 创建用户名标签
                const userNameLabel = document.createElement('div');
                userNameLabel.className = 'user-name-label';
                userNameLabel.textContent = currentUserName || '用户';

                // 将消息和用户名添加到容器
                messageContainer.appendChild(messageElement);
                messageContainer.appendChild(userNameLabel);

                // 将容器添加到聊天区域
                chatContainer.appendChild(messageContainer);

                // 滚动到最新消息
                chatContainer.scrollTop = chatContainer.scrollHeight;
            }

            // 显示错误
            function showError(message) {
                errorMessage.textContent = message;
                errorContainer.style.display = 'block';
                setTimeout(() => {
                    errorContainer.style.display = 'none';
                }, 5000);
            }

            // 修改sendMessage函数，确保连接在响应完成后彻底关闭
            async function sendMessage() {
                const message = userInput.value.trim();

                // 消息验证
                if (!message) {
                    console.log('消息为空，不发送');
                    return;
                }

                // 防止重复发送：检查是否正在处理消息
                if (isProcessingMessage) {
                    console.log('消息正在处理中，请稍候...');
                    return;
                }

                // 防止频繁发送：检查与上一条消息的时间间隔(至少1秒)
                const now = Date.now();
                if (now - lastSentTime < 1000) {
                    console.log('发送过于频繁，请稍候再试...');
                    return;
                }

                // 防止重复内容：检查是否与上一条消息内容相同
                if (message === lastSentMessage) {
                    console.log('请勿重复发送相同内容');
                    return;
                }

                // 更新状态
                isProcessingMessage = true;
                lastSentMessage = message;
                lastSentTime = now;

                // 重置对话状态 - 清除之前的思考和响应容器ID
                const oldThinking = document.getElementById('thinkingContainer'); // This ID is for a different type of thinking box
                if (oldThinking) {
                    oldThinking.id = 'completed-thinking-' + Date.now();
                }

                // This ensures that IF there's an element with ID 'responseContainer' from a *previous,
                // possibly stuck* message, its ID is changed so it doesn't conflict.
                // This ID is not strictly needed for the new instance-based logic but can help clear old global IDs.
                const oldResponseWithGlobalID = document.getElementById('responseContainer'); 
                if (oldResponseWithGlobalID) { 
                    // console.log("sendMessage: Renaming old #responseContainer to completed-response-...");
                    oldResponseWithGlobalID.id = 'completed-response-' + Date.now(); 
                }
                currentActiveResponseContainer = null; // Ensure it's null before a new stream potentially starts

                // 禁用发送按钮并显示加载指示器
                sendBtn.disabled = true;
                typingIndicator.style.display = 'block';

                // 显示用户消息
                addUserMessage(message);

                // 清空输入框
                userInput.value = '';

                // 保存用户消息
                lastUserMessage = message;

                // 设置安全计时器，确保界面状态最终会被重置
                if (messageTimeout) {
                    clearTimeout(messageTimeout);
                }

                // 添加提醒计时器 - 如果响应时间超过10秒，显示等待消息
                const reminderTimeout = setTimeout(() => {
                    // 如果还在处理中，添加一个等待提示
                    if (isProcessingMessage) {
                        const waitingMessage = document.createElement('div');
                        waitingMessage.className = 'system-message waiting-message';
                        waitingMessage.id = 'waiting-message';
                        waitingMessage.innerHTML = '<i class="fas fa-hourglass-half"></i> 请求处理中，可能需要较长时间，请耐心等待...';
                        chatContainer.appendChild(waitingMessage);
                        chatContainer.scrollTop = chatContainer.scrollHeight;
                    }
                }, 10000); // 10秒后显示等待消息

                // 设置主安全计时器
                messageTimeout = setTimeout(() => {
                    console.log('安全计时器触发：强制重置界面状态');
                    isProcessingMessage = false;
                    sendBtn.disabled = false;
                    typingIndicator.style.display = 'none';

                    // 关闭当前EventSource连接
                    if (currentEventSource) {
                        closeEventSource();
                    }

                    // 移除等待消息
                    const waitingMessage = document.getElementById('waiting-message');
                    if (waitingMessage) {
                        waitingMessage.remove();
                    }

                    // 显示超时错误提示
                    handleError("消息响应超时，请稍后重试。如果问题持续存在，请刷新页面。");

                }, 30000); // 30秒超时

                try {
                    // 构建请求URL - 修改这部分
                    const endpointURL = apiEndpoint.value;

                    // 获取用户ID参数
                    const urlParams = getUrlParams();
                    const userId = urlParams.userId || 'anonymous';

                    // 使用POST请求处理非流式API
                    if (endpointURL === "/api/llm/chat") {
                        // 准备POST请求体
                        const payload = {
                            message: message,
                            session_id: currentSessionId,
                            user_id: userId,
                            show_thinking: document.getElementById('showThinking').checked
                        };

                        // 发送POST请求
                        fetch(`${window.location.origin}${endpointURL}`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify(payload)
                        })
                            .then(response => response.text())
                            .then(text => {
                                console.log("Raw response:", text); // Debug: log the raw response

                                let data;
                                if (text.trim().startsWith('data:')) {
                                    // Handle multi-line SSE responses
                                    if (text.includes('\n\n')) {
                                        // Multiple SSE messages - take the last complete one
                                        const messages = text.split('\n\n').filter(m => m.trim());
                                        if (messages.length > 0) {
                                            const lastMessage = messages[messages.length - 1];
                                            const jsonStr = lastMessage.replace(/^data: /, '');
                                            data = JSON.parse(jsonStr);
                                        }
                                    } else {
                                        // Single SSE message
                                        const jsonStr = text.replace(/^data: /, '');
                                        data = JSON.parse(jsonStr);
                                    }
                                } else {
                                    // Regular JSON
                                    data = JSON.parse(text);
                                }

                                // Process the data
                                if (data) {
                                    processEvent(data);
                                }

                                // Mark as complete
                                isProcessingMessage = false;
                                sendBtn.disabled = false;
                                typingIndicator.style.display = 'none';

                                // Clear safety timer
                                if (messageTimeout) {
                                    clearTimeout(messageTimeout);
                                }
                            })
                            .catch(error => {
                                console.error('fetch错误:', error);
                                console.log("Error details:", error.message);
                                handleError('请求错误: ' + error.message);
                                // Restore UI state
                                isProcessingMessage = false;
                                sendBtn.disabled = false;
                                typingIndicator.style.display = 'none';
                            });

                        return; // 结束函数执行，不再创建EventSource
                    }

                    // 对于流式API，继续使用EventSource
                    const paramString = `session_id=${encodeURIComponent(currentSessionId)}&message=${encodeURIComponent(message)}&user_id=${encodeURIComponent(userId)}`;
                    const showThinkingParam = document.getElementById('showThinking').checked ? '&show_thinking=true' : '&show_thinking=false';
                    const timeParam = `&_t=${Date.now()}`;
                    const fullUrl = `${window.location.origin}${endpointURL}?${paramString}${showThinkingParam}${timeParam}`;

                    console.log('Opening SSE connection to:', fullUrl);

                    // 关闭之前的事件源并设置为null
                    if (currentEventSource) {
                        console.log('关闭之前的EventSource连接');
                        currentEventSource.close();
                        currentEventSource = null;
                    }

                    // 创建EventSource连接
                    const eventSource = new EventSource(fullUrl);
                    currentEventSource = eventSource;

                    // 添加连接打开事件处理
                    eventSource.onopen = function () {
                        console.log('EventSource连接已打开');
                    };

                    // 设置onmessage处理程序
                    eventSource.onmessage = function (event) {
                        try {
                            const data = JSON.parse(event.data);
                            processEvent(data);
                        } catch (e) {
                            console.error('处理消息时出错:', e, event.data);
                            handleError('处理响应时出错: ' + e.message);

                            // 确保连接关闭
                            closeEventSource();
                            isProcessingMessage = false;
                        }
                    };

                    // 设置onerror处理程序，确保连接出错时彻底关闭
                    eventSource.onerror = function (event) {
                        console.error('EventSource连接错误:', event);
                        handleError('连接错误，请刷新页面重试');

                        // 确保连接关闭
                        closeEventSource();
                        isProcessingMessage = false;
                    };
                } catch (error) {
                    console.error('发送消息时出错:', error);
                    handleError('发送消息时出错: ' + error.message);

                    // 恢复状态
                    typingIndicator.style.display = 'none';
                    sendBtn.disabled = false;
                    isProcessingMessage = false;

                    // 清除安全计时器
                    if (messageTimeout) {
                        clearTimeout(messageTimeout);
                    }
                }
            }

            // 添加一个专门的函数用于关闭EventSource连接，确保彻底关闭
            function closeEventSource() {
                if (currentEventSource) {
                    console.log('关闭EventSource连接');

                    // 移除所有事件监听器
                    currentEventSource.onmessage = null;
                    currentEventSource.onerror = null;
                    currentEventSource.onopen = null;

                    // 关闭连接
                    currentEventSource.close();
                    currentEventSource = null;

                    // 恢复UI状态
                    typingIndicator.style.display = 'none';
                    sendBtn.disabled = false;

                    // 清除安全计时器
                    if (messageTimeout) {
                        clearTimeout(messageTimeout);
                    }

                    // 移除等待消息
                    const waitingMessage = document.getElementById('waiting-message');
                    if (waitingMessage) {
                        waitingMessage.remove();
                    }
                }
            }




            // Function to show a toast notification
            function showToast(message, duration = 3000) {
                // Create toast element if it doesn't exist
                let toast = document.getElementById('toast');
                if (!toast) {
                    toast = document.createElement('div');
                    toast.id = 'toast';
                    toast.className = 'toast';
                    document.body.appendChild(toast);
                }

                // Set message and show toast
                toast.textContent = message;
                toast.classList.add('show');

                // Hide toast after duration
                setTimeout(() => {
                    toast.classList.remove('show');
                }, duration);
            }

            // 文本弹窗功能
            const textModal = document.getElementById('textModal');
            const textModalBody = document.getElementById('textModalBody');
            const textModalTitle = document.querySelector('.text-modal-title');
            const textModalClose = document.querySelector('.text-modal-close');
            const textModalCloseBtn = document.getElementById('textModalCloseBtn');

            // 关闭弹窗函数
            function closeTextModal() {
                textModal.style.display = 'none';
                document.body.style.overflow = 'auto'; // 恢复body滚动
            }

            // 关闭按钮点击事件
            textModalClose.addEventListener('click', closeTextModal);
            textModalCloseBtn.addEventListener('click', closeTextModal);

            // 点击弹窗外部关闭弹窗
            window.addEventListener('click', (e) => {
                if (e.target === textModal) {
                    closeTextModal();
                }
            });

            // 显示详细内容弹窗
            function showDetailModal(title, content, isCode = false, roleId = null, roleIndex = null) {
                textModalTitle.textContent = title || '详细内容';

                // 清空之前的内容
                textModalBody.innerHTML = '';

                // 创建文本区域
                const textarea = document.createElement('textarea');
                textarea.className = 'form-control';
                textarea.style.width = '100%';
                textarea.style.minHeight = '300px';
                textarea.value = content || '';
                textModalBody.appendChild(textarea);

                // 存储角色ID和索引
                textModal.dataset.roleId = roleId || '';
                textModal.dataset.roleIndex = roleIndex || '';

                // 显示或隐藏更新按钮
                const updateBtn = document.getElementById('textModalUpdateBtn');
                if (updateBtn) {
                    updateBtn.style.display = roleId ? 'inline-block' : 'none';
                }

                // 显示弹窗
                textModal.style.display = 'block';
                document.body.style.overflow = 'hidden'; // 防止背景滚动
            }

            // 修改文本弹窗元素，添加更新按钮
            // 在 <div class="text-modal-footer"> 中添加
            textModal.querySelector('.text-modal-footer').innerHTML = `
                <button id="textModalUpdateBtn" class="btn btn-primary">更新提示词</button>
                <button id="textModalCloseBtn" class="btn btn-secondary">关闭</button>
            `;

            // 更新事件监听
            document.getElementById('textModalUpdateBtn').addEventListener('click', updateSystemPrompt);
            document.getElementById('textModalCloseBtn').addEventListener('click', closeTextModal);

            // 添加更新系统提示词的函数
            async function updateSystemPrompt() {
                // 获取角色ID和提示词内容
                const roleId = textModal.dataset.roleId;
                const roleIndex = parseInt(textModal.dataset.roleIndex || '-1');
                const newPrompt = textModalBody.querySelector('textarea').value.trim();

                if (!roleId || roleIndex < 0 || !currentSessionId) {
                    showToast('无法更新: 缺少必要信息');
                    return;
                }

                try {
                    // 显示加载状态
                    const updateBtn = document.getElementById('textModalUpdateBtn');
                    const originalText = updateBtn.textContent;
                    updateBtn.textContent = '更新中...';
                    updateBtn.disabled = true;

                    // 获取当前会话信息
                    const response = await fetch(`/api/custom-sessions/${currentSessionId}`);
                    if (!response.ok) throw new Error('获取会话信息失败');
                    const sessionData = await response.json();

                    // 更新指定角色的系统提示词
                    if (!sessionData.roles || !sessionData.roles[roleIndex]) {
                        throw new Error('找不到指定角色');
                    }

                    // 创建更新请求数据
                    const updateData = {
                        roles: sessionData.roles.map((role, idx) => {
                            if (idx === roleIndex) {
                                return {
                                    ...role,
                                    system_prompt: newPrompt
                                };
                            }
                            return role;
                        })
                    };

                    // 发送更新请求
                    const updateResponse = await fetch(`/api/custom-sessions/${currentSessionId}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(updateData)
                    });

                    if (!updateResponse.ok) throw new Error('更新失败');

                    // 显示成功消息
                    showToast('系统提示词更新成功');

                    // 刷新角色信息显示
                    fetchSessionRoles(currentSessionId);

                    // 关闭弹窗
                    closeTextModal();
                } catch (error) {
                    console.error('更新系统提示词失败:', error);
                    showToast(`更新失败: ${error.message}`);
                } finally {
                    // 恢复按钮状态
                    const updateBtn = document.getElementById('textModalUpdateBtn');
                    updateBtn.textContent = '更新提示词';
                    updateBtn.disabled = false;
                }
            }

            // 事件监听
            sendBtn.addEventListener('click', sendMessage);

            userInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });


            // 更新当前角色的显示
            function updateCurrentRoleDisplay() {
                if (!currentRole) return;

                // 如果界面中有显示当前角色的元素，则更新
                const roleDisplay = document.getElementById('current-role-info');
                if (roleDisplay) {
                    roleDisplay.innerHTML = `当前角色: ${currentRole.name} (ID: ${currentRole.id})`;

                    const avatarEl = document.getElementById('current-role-avatar');
                    if (avatarEl && currentRole.avatar) {
                        avatarEl.src = currentRole.avatar;
                        avatarEl.style.display = 'inline-block';
                    }
                }
            }


            // 错误处理函数
            function handleError(errorMsg) {
                console.error('Error:', errorMsg);

                // 显示错误容器
                errorContainer.style.display = 'block';
                errorMessage.textContent = errorMsg;

                // 3秒后自动隐藏错误信息
                setTimeout(() => {
                    errorContainer.style.display = 'none';
                }, 5000);

                // 恢复界面状态
                if (typingIndicator) {
                    typingIndicator.style.display = 'none';
                }

                if (sendBtn) {
                    sendBtn.disabled = false;
                }

                // 关闭当前事件源
                if (currentEventSource) {
                    currentEventSource.close();
                    currentEventSource = null;
                }

                // 标记消息处理完成
                isProcessingMessage = false;

                // 清除安全计时器
                if (messageTimeout) {
                    clearTimeout(messageTimeout);
                }

                // 移除等待消息
                const waitingMessage = document.getElementById('waiting-message');
                if (waitingMessage) {
                    waitingMessage.remove();
                }
            }

            // Create a thinking container
            function createThinkingContainer(reason) {
                // 检查是否已存在思考容器，如果存在则直接返回
                let container = document.getElementById('thinkingContainer');
                if (container) {
                    return container;
                }

                // 创建新的思考容器
                container = document.createElement('div');
                container.id = 'thinkingContainer';
                container.className = 'thinking-container';

                // 创建标题区域
                const header = document.createElement('div');
                header.className = 'thinking-header';

                // 添加标题
                const title = document.createElement('div');
                title.className = 'thinking-title';
                // 根据reason参数确定显示的图标和文本
                if (reason === '知识库检索结果') {
                    title.innerHTML = '<i class="fas fa-search"></i> 知识库检索结果';
                } else {
                    title.innerHTML = '<i class="fas fa-brain"></i> 思考过程';
                }
                header.appendChild(title);

                // 添加原因（如有）
                if (reason) {
                    const reasonElem = document.createElement('div');
                    reasonElem.className = 'thinking-reason';
                    reasonElem.textContent = reason;
                    header.appendChild(reasonElem);
                }

                // 添加切换按钮
                const toggleBtn = document.createElement('button');
                toggleBtn.className = 'thinking-toggle';
                toggleBtn.innerHTML = '<i class="fas fa-chevron-up"></i>';
                toggleBtn.onclick = function (e) {
                    e.stopPropagation(); // 防止事件冒泡
                    toggleThinkingContent(container);
                };
                header.appendChild(toggleBtn);

                // 添加点击整个标题区域的事件
                header.onclick = function () {
                    toggleThinkingContent(container);
                };

                // 将标题区域添加到容器
                container.appendChild(header);

                // 创建内容区域
                const content = document.createElement('div');
                content.className = 'thinking-content';
                container.appendChild(content);

                return container;
            }

            // 完成思考容器的函数
            function finalizeThinkingContainer(docsCount, timeTaken) {
                const container = document.getElementById('thinkingContainer');
                if (!container) return;

                // 检查是否已有总结区域
                if (container.querySelector('.thinking-summary')) return;

                // 创建总结区域
                const summary = document.createElement('div');
                summary.className = 'thinking-summary';

                // 格式化时间（将毫秒转换为秒，保留两位小数）
                const timeInSeconds = timeTaken / 1000;
                const formattedTime = timeInSeconds.toFixed(0);

                // 更新标题为DeepSeek风格
                const header = container.querySelector('.thinking-header');
                if (header) {
                    // 清除旧类名并添加新类名，确保样式应用
                    header.classList.remove('thinking-header');
                    header.classList.add('deepseek-thinking-header');

                    // 清空现有标题内容
                    header.innerHTML = '';

                    // 添加新的DeepSeek风格标题
                    const title = document.createElement('div');
                    title.className = 'deepseek-thinking-title';
                    title.textContent = `Deep thinking completed (Time taken: ${formattedTime} seconds)`;
                    header.appendChild(title);

                    // 添加折叠按钮
                    const toggleBtn = document.createElement('button');
                    toggleBtn.className = 'thinking-toggle';
                    toggleBtn.innerHTML = '<i class="fas fa-chevron-up"></i>';
                    toggleBtn.onclick = function (e) {
                        e.stopPropagation(); // 防止事件冒泡
                        toggleThinkingContent(container);
                    };
                    header.appendChild(toggleBtn);

                    // 添加点击整个标题区域的事件
                    header.onclick = function () {
                        toggleThinkingContent(container);
                    };
                }

                // 创建分隔线，显示角色回答分隔
                const divider = document.createElement('div');
                divider.className = 'thinking-response-divider';
                divider.setAttribute('data-role-name', currentRole ? currentRole.name : '助手');
                chatContainer.appendChild(divider);
            }

            // 新增函数：切换思考内容的显示/隐藏
            function toggleThinkingContent(container) {
                const content = container.querySelector('.thinking-content');
                const references = container.querySelector('.thinking-references');
                const toggleBtn = container.querySelector('.thinking-toggle i');

                // 检查当前状态
                const isExpanded = content.style.display !== 'none';

                if (isExpanded) {
                    // 收起内容
                    content.style.display = 'none';
                    if (references) references.style.display = 'none';
                    toggleBtn.className = 'fas fa-chevron-down';
                } else {
                    // 展开内容
                    content.style.display = 'block';
                    if (references) references.style.display = 'block';
                    toggleBtn.className = 'fas fa-chevron-up';
                }
            }

            // 添加思考步骤的函数
            function appendThinkingStep(content) {
                if (!content) return;

                const thinkingContainer = document.getElementById('thinkingContainer');
                if (!thinkingContainer) return;

                const contentContainer = thinkingContainer.querySelector('.thinking-content');
                if (!contentContainer) return;

                // 检查内容是否为对象格式
                let textContent = content;

                // 如果content是对象，尝试解析thinking中的数据
                if (typeof content === 'object') {
                    if (content.content) {
                        textContent = content.content;
                    } else if (content.thinking) {
                        textContent = content.thinking;
                    } else {
                        // 尝试将对象转换为字符串显示
                        try {
                            textContent = JSON.stringify(content, null, 2);
                        } catch (e) {
                            console.error('无法解析思考内容:', e);
                            textContent = '无法显示的思考内容';
                        }
                    }
                }

                // 创建思考步骤元素
                const step = document.createElement('div');
                step.className = 'thinking-step';

                // 添加内容
                const stepContent = document.createElement('div');
                stepContent.className = 'thinking-step-content';
                stepContent.textContent = textContent;
                step.appendChild(stepContent);

                // 添加到思考内容容器
                contentContainer.appendChild(step);

                // 滚动到最新内容
                chatContainer.scrollTop = chatContainer.scrollHeight;
            }

            // 添加思考错误的函数
            function appendThinkingError(error) {
                if (!error) return;

                const thinkingContainer = document.getElementById('thinkingContainer');
                if (!thinkingContainer) return;

                // 创建错误区域
                const errorElem = document.createElement('div');
                errorElem.className = 'thinking-error';
                errorElem.innerHTML = `<i class="fas fa-exclamation-triangle"></i> ${error}`;

                // 添加到思考容器
                thinkingContainer.appendChild(errorElem);

                // 滚动到最新内容
                chatContainer.scrollTop = chatContainer.scrollHeight;
            }

            // 添加引用卡片的函数
            function appendReferenceCard(title, content, relevance) {
                if (!title && !content) return;

                const thinkingContainer = document.getElementById('thinkingContainer');
                if (!thinkingContainer) return;

                // 获取或创建引用区域
                let referencesContainer = thinkingContainer.querySelector('.thinking-references');
                if (!referencesContainer) {
                    referencesContainer = document.createElement('div');
                    referencesContainer.className = 'thinking-references';
                    thinkingContainer.appendChild(referencesContainer);
                }

                // 创建引用卡片
                const card = document.createElement('div');
                card.className = 'reference-card';

                // 处理标题中的<em>标签
                title = title.replace(/<em>(.*?)<\/em>/g, '"$1"');

                // 添加标题
                const titleElem = document.createElement('div');
                titleElem.className = 'reference-title';

                // 分析标题确定文档类型
                let docType = '文档';
                if (title.includes('.txt') || title.includes('.md')) {
                    docType = '文本文件';
                } else if (title.includes('.pdf')) {
                    docType = 'PDF文档';
                } else if (title.includes('.html') || title.includes('.htm')) {
                    docType = '网页';
                } else if (title.includes('.doc') || title.includes('.docx')) {
                    docType = 'Word文档';
                } else if (title.includes('.xls') || title.includes('.xlsx')) {
                    docType = 'Excel表格';
                } else if (title.includes('.ppt') || title.includes('.pptx')) {
                    docType = 'PPT演示';
                } else if (title.toLowerCase().includes('http')) {
                    docType = '网页链接';
                }

                // 生成新标题与类型信息
                const displayTitle = title;
                titleElem.innerHTML = `<i class="fas fa-file-alt"></i> <span style="color:#1a73e8;">[${docType}]</span> ${displayTitle}`;
                card.appendChild(titleElem);

                // 处理内容中的<em>标签
                content = content.replace(/<em>(.*?)<\/em>/g, '"$1"');

                // 添加内容预览 - 始终显示内容预览，确保不为空
                if (content) {
                    const previewElem = document.createElement('div');
                    previewElem.className = 'reference-preview';

                    // 显示完整内容，不再截取
                    previewElem.textContent = content;
                    card.appendChild(previewElem);
                } else {
                    // 如果没有内容，显示一个提示
                    const noContentElem = document.createElement('div');
                    noContentElem.className = 'reference-preview';
                    noContentElem.innerHTML = '<i>没有获取到内容</i>';
                    card.appendChild(noContentElem);
                }

                // 添加相关性评分（如果有）
                if (relevance && relevance !== '0') {
                    const scoreContainer = document.createElement('div');
                    scoreContainer.className = 'reference-score';
                    scoreContainer.innerHTML = `相关度: <b>${parseFloat(relevance).toFixed(2)}</b>`;
                    titleElem.appendChild(scoreContainer);
                }

                // 添加查看全文按钮
                if (content && content.length > 0) {
                    const viewButton = document.createElement('button');
                    viewButton.className = 'reference-view-btn';
                    viewButton.innerHTML = '<i class="fas fa-expand-alt"></i> 查看全文';
                    viewButton.onclick = function () {
                        showDetailModal(title || '检索内容', content);
                    };
                    card.appendChild(viewButton);
                }

                // 添加卡片到引用容器
                referencesContainer.appendChild(card);

                // 滚动到最新内容
                chatContainer.scrollTop = chatContainer.scrollHeight;
            }

            /* 修改createResponseContainer函数 */
            function createResponseContainer() {
                const container = document.createElement('div');
                container.className = 'response-container'; // Rely on class for styling
                
                // 添加角色标题区域
                const header = document.createElement('div');
                header.className = 'chat-header';
                
                const headerTitle = document.createElement('div');
                headerTitle.className = 'chat-header-title';
                headerTitle.textContent = currentRole ? currentRole.name : 'AI';
                
                header.appendChild(headerTitle);
                
                // 创建情绪标签容器，但先不添加内容
                const emotionTag = document.createElement('div');
                emotionTag.className = 'header-emotion-tag';
                emotionTag.style.display = 'none'; // 默认隐藏，有情绪时才显示
                header.appendChild(emotionTag);
                
                container.appendChild(header);

                // 创建事件标签容器，但不再包含情绪标签
                const eventTags = document.createElement('div');
                eventTags.className = 'event-tags';
                container.appendChild(eventTags);

                // 创建消息内容区域
                const messageBox = document.createElement('div');
                messageBox.className = 'message-box';
                
                const content = document.createElement('div');
                content.className = 'response-content loading';
                
                messageBox.appendChild(content);
                container.appendChild(messageBox);

                return container;
            }

            // 修改appendResponseContent函数，修复HTML内容追加问题
            function appendResponseContent(text) {
                if (!text) return;

                console.log('追加内容:', text); // 添加调试信息

                const responseContainer = document.getElementById('responseContainer');
                if (!responseContainer) {
                    console.error('找不到响应容器');
                    return;
                }

                const content = responseContainer.querySelector('.response-content');
                if (!content) {
                    console.error('找不到内容区域');
                    return;
                }

                // 使用常规属性而非自定义属性
                if (!content.dataset.fullText) {
                    content.dataset.fullText = '';
                    console.log('初始化文本为空');
                }

                // 追加并记录
                content.dataset.fullText += text;
                console.log('当前累积文本:', content.dataset.fullText);

                // 直接设置HTML内容而非textContent
                content.innerHTML = content.dataset.fullText;

                // 移除加载指示器并滚动
                content.classList.remove('loading');
                chatContainer.scrollTop = chatContainer.scrollHeight;
            }

            // 修改完成响应容器函数，移除反馈按钮
            function finalizeResponseContainer() {
                const responseContainer = document.getElementById('responseContainer');
                if (!responseContainer) return;

                // 移除加载状态
                const content = responseContainer.querySelector('.response-content');
                if (content) {
                    content.classList.remove('loading');
                }

                // 滚动到最新内容
                chatContainer.scrollTop = chatContainer.scrollHeight;
            }

            // 添加页面初始化处理
            // 尝试处理URL参数，如果处理失败，则使用默认行为
            const paramsProcessed = processUrlParams();

            // 初始化，创建一个新会话
            if (!paramsProcessed) {
                // 仅当未从URL处理会话时才显示创建会话的按钮
                createSessionBtn.disabled = false;
                createSessionBtn.textContent = "创建会话";
            }

            // 添加对文本展开功能的处理
            document.addEventListener('click', function (e) {
                if (e.target.closest('.text-expandable')) {
                    const expandable = e.target.closest('.text-expandable');
                    const content = decodeURIComponent(expandable.getAttribute('data-content') || '');
                    const title = decodeURIComponent(expandable.getAttribute('data-title') || '详细内容');
                    const roleId = expandable.getAttribute('data-role-id');
                    const roleIndex = expandable.getAttribute('data-role-index');

                    if (content) {
                        showDetailModal(title, content, false, roleId, roleIndex);
                    }
                }
            });

            // 检查MarkdownIt是否可用
            if (window.markdownit) {
                console.log('Markdown rendering enabled');
                markdownEnabled = true;
            } else {
                console.warn('Markdown-it library not found, rendering plain text');
            }

            // 在页面加载时添加等待样式
            document.addEventListener('DOMContentLoaded', function () {
                addWaitingStyles();
            });

            // 使用全局变量存储当前累积内容
            window.currentMessageContent = '';

            function processEvent(data) {
                console.log('Processing event:', data);

                // 处理角色选择事件
                if (data.event === "role_selected") {
                    currentRole = {
                        id: data.role_id || "unknown",
                        name: data.role_name || "AI"
                    };
                    console.log('Role selected:', currentRole);

                    // If a previous active container exists, finalize it visually or mark as completed
                    if (currentActiveResponseContainer) {
                         // Optionally add a class or visual cue that this container is now "old"
                         currentActiveResponseContainer.classList.add('previous-response');
                    }

                    currentActiveResponseContainer = createResponseContainer(); // createResponseContainer returns the new div
                    chatContainer.appendChild(currentActiveResponseContainer);
                    
                    const headerTitle = currentActiveResponseContainer.querySelector('.chat-header-title');
                    if (headerTitle) headerTitle.textContent = data.role_name;
                    
                    const emotionTag = currentActiveResponseContainer.querySelector('.header-emotion-tag');
                    if (emotionTag && data.emotion) { // Assuming role_selected might also provide initial emotion
                        emotionTag.textContent = data.emotion; 
                        emotionTag.style.display = 'inline-block';
                    } else if (emotionTag) {
                         emotionTag.style.display = 'none'; // Hide if no emotion
                    }
                    
                    isThinkingCompleted = false;
                    isResponseStarted = false; 
                    previousFullMessage = ''; 
                    currentCleanedContentForDisplay = ''; // RESET HERE
                    
                    return;
                }

                // Ensure currentActiveResponseContainer exists for subsequent events
                if (!currentActiveResponseContainer && data.event !== "stream_end" && data.event !== "error" && data.event !== "complete") {
                    // This might happen if role_selected was missed or thinking is the very first event.
                    console.warn(`Event ${data.event} received but currentActiveResponseContainer is null. Attempting to create.`);
                    if (!currentRole && data.role_name) { // Try to set role if available
                        currentRole = { name: data.role_name, id: data.role_id || "unknown" };
                    }
                    currentActiveResponseContainer = createResponseContainer();
                    chatContainer.appendChild(currentActiveResponseContainer);
                    // Update header if role info is in this event
                    const headerTitle = currentActiveResponseContainer.querySelector('.chat-header-title');
                    if (headerTitle && currentRole) headerTitle.textContent = currentRole.name;
                }


                // 处理情绪事件 
                if (data.event === "emotion") {
                    if (!currentActiveResponseContainer) { console.error("Emotion event: currentActiveResponseContainer is null!"); return; }
                    
                    const emotionTag = currentActiveResponseContainer.querySelector('.header-emotion-tag');
                    if (emotionTag) {
                        emotionTag.textContent = `${data.emotion}`;
                        // Example: Update style based on emotion, or use a predefined class
                        // emotionTag.className = `header-emotion-tag emotion-${data.emotion_type || 'generic'}`;
                        emotionTag.style.backgroundColor = '#e8f5e9'; 
                        emotionTag.style.color = '#388e3c';
                        emotionTag.style.display = 'inline-block'; 
                    }
                    return;
                }
                
                // 处理思考事件
                if (data.event === "thinking") {
                    isThinkingCompleted = false;

                    if (!currentActiveResponseContainer) { 
                        console.error("Thinking event: currentActiveResponseContainer is null! This shouldn't happen if role_selected was processed.");
                        // Fallback: Attempt to create one if absolutely necessary
                        if (!currentRole && data.role_name) { currentRole = { name: data.role_name, id: data.role_id || "unknown" }; }
                        currentActiveResponseContainer = createResponseContainer();
                        chatContainer.appendChild(currentActiveResponseContainer);
                        const headerTitle = currentActiveResponseContainer.querySelector('.chat-header-title');
                        if (headerTitle && currentRole) headerTitle.textContent = currentRole.name;
                        console.log("Thinking event: Created fallback currentActiveResponseContainer.");
                    }
                    
                    previousFullMessage = '';
                    currentCleanedContentForDisplay = ''; // RESET HERE
                    return;
                }

                // 处理思考内容
                if (data.event === "thinking_content") {
                    if (!currentActiveResponseContainer) { console.error("thinking_content: currentActiveResponseContainer is null!"); return; }
                    // thinkingContents.push({ content: data.content, type: data.type }); // REMOVED - No longer populating this array

                    let thinkingHeaderContainer = currentActiveResponseContainer.querySelector('.thinking-box-header');
                    let thinkingBox = currentActiveResponseContainer.querySelector('.thinking-content-box');
                    let thinkingContentWrapper;
                    let thinkingAggregatorSpan;

                    // Ensure header exists
                    if (!thinkingHeaderContainer) {
                        thinkingHeaderContainer = document.createElement('div');
                        thinkingHeaderContainer.className = 'thinking-box-header';
                        // Default to expanded if content is being added
                        thinkingHeaderContainer.innerHTML = '<span>思考中...</span><button class="thinking-box-toggle"><i class="fas fa-chevron-up"></i></button>'; 
                        thinkingHeaderContainer.querySelector('.thinking-box-toggle').addEventListener('click', () => {
                            const boxToToggle = currentActiveResponseContainer.querySelector('.thinking-content-box');
                            if (boxToToggle) toggleThinkingBox(boxToToggle);
                        });
                        const messageBox = currentActiveResponseContainer.querySelector('.message-box');
                        if (messageBox) currentActiveResponseContainer.insertBefore(thinkingHeaderContainer, messageBox);
                        else currentActiveResponseContainer.appendChild(thinkingHeaderContainer);
                    } else {
                        const headerSpan = thinkingHeaderContainer.querySelector('span');
                        if (headerSpan && !isThinkingCompleted) headerSpan.textContent = '思考中...'; // Keep as "思考中..." if not completed
                    }

                    // Ensure content box and wrapper exist
                    if (!thinkingBox) {
                        thinkingBox = document.createElement('div');
                        thinkingBox.className = 'thinking-content-box';
                        thinkingContentWrapper = document.createElement('div');
                        thinkingContentWrapper.className = 'thinking-content-wrapper';
                        thinkingBox.appendChild(thinkingContentWrapper);

                        // Create the single aggregator span here when the box is first created
                        thinkingAggregatorSpan = document.createElement('span');
                        thinkingAggregatorSpan.className = 'thinking-text-aggregator typing-text'; // Apply base styles
                        thinkingContentWrapper.appendChild(thinkingAggregatorSpan);

                        if (thinkingHeaderContainer.nextSibling) currentActiveResponseContainer.insertBefore(thinkingBox, thinkingHeaderContainer.nextSibling);
                        else currentActiveResponseContainer.appendChild(thinkingBox);
                    } else {
                        thinkingContentWrapper = thinkingBox.querySelector('.thinking-content-wrapper');
                        thinkingAggregatorSpan = thinkingContentWrapper.querySelector('.thinking-text-aggregator');
                        if (!thinkingAggregatorSpan) { // Should exist if box exists, but as a fallback
                            thinkingAggregatorSpan = document.createElement('span');
                            thinkingAggregatorSpan.className = 'thinking-text-aggregator typing-text';
                            thinkingContentWrapper.appendChild(thinkingAggregatorSpan);
                        }
                    }

                    // Ensure box and wrapper are visible when new content arrives
                    thinkingBox.style.display = 'block';
                    if(thinkingContentWrapper) thinkingContentWrapper.style.display = 'block';
                    const toggleIcon = thinkingHeaderContainer.querySelector('.thinking-box-toggle i');
                    if (toggleIcon) toggleIcon.className = 'fas fa-chevron-up'; // Set to expanded

                    // Apply RAG knowledge style to the aggregator if any part is RAG
                    // This makes the entire thinking block blue if it contains RAG.
                    // If mixed styling is needed *within* the block, server would need to send pre-formatted HTML
                    // or more complex client-side logic would be required.
                    if (data.type === "rag_knowledge" && !thinkingAggregatorSpan.classList.contains('rag-knowledge')) {
                        thinkingAggregatorSpan.classList.add('rag-knowledge');
                    }
                    
                    displayWithTypewriter(thinkingAggregatorSpan, data.content, true); 

                    // if(thinkingContentWrapper) thinkingContentWrapper.appendChild(document.createElement('br')); // REMOVED - No automatic <br>
                    if (chatContainer) chatContainer.scrollTop = chatContainer.scrollHeight;
                    return;
                }

                // 处理思考完成事件
                if (data.event === "thinking_completed" || data.event === "rag_thinking_completed") {
                    if (!currentActiveResponseContainer) { console.error("thinking_completed: currentActiveResponseContainer is null!"); return; }
                    console.log("Thinking completed event received.");
                    isThinkingCompleted = true; 
                    
                    const thinkingHeader = currentActiveResponseContainer.querySelector('.thinking-box-header');
                    const thinkingHeaderSpan = thinkingHeader ? thinkingHeader.querySelector('span') : null;
                    
                    if (thinkingHeaderSpan) {
                        thinkingHeaderSpan.textContent = '思考完成'; 
                    }
                    
                    // Content remains visible, user can collapse. No change to thinkingBoxElement display here.
                    console.log("Thinking completed. Content displayed should remain visible.");
                    return;
                }

                // 处理内容消息 (final response part)
                if (data.content && data.role_name) {
                    console.log("Final Content Event:", { data_content: data.content, isThinkingCompleted: isThinkingCompleted, previousFullMessage_before_call: previousFullMessage });
                    
                    if (isThinkingCompleted) { 
                        if (currentActiveResponseContainer) {
                            const contentDisplayElement = currentActiveResponseContainer.querySelector('.response-content'); 
                            if (contentDisplayElement) {
                                const thinkingBoxToCollapse = currentActiveResponseContainer.querySelector('.thinking-content-box');
                                if (thinkingBoxToCollapse) {
                                    const wrapper = thinkingBoxToCollapse.querySelector('.thinking-content-wrapper');
                                    if (wrapper && wrapper.style.display !== 'none') {
                                        toggleThinkingBox(thinkingBoxToCollapse, true); // forceCollapse
                                        console.log("Ensured thinking box is collapsed before showing final content.");
                                    }
                                }

                                if (!contentDisplayElement.dataset.initialized) { 
                                    contentDisplayElement.dataset.initialized = 'true';
                                    isResponseStarted = true; 
                                }
                                displayWithTypewriter(contentDisplayElement, data.content, false); 
                            } else {
                                console.error("'.response-content' element not found within currentActiveResponseContainer!");
                            }
                        } else {
                            console.error("currentActiveResponseContainer is null for final content!"); 
                        }
                    } else {
                        console.warn("Received final content, but isThinkingCompleted is false. Content:", data.content);
                    }
                    return;
                }

                // 处理RAG检索结果
                if (data.event === 'rag_retrieved') {
                    if (!currentActiveResponseContainer) { console.error("rag_retrieved: currentActiveResponseContainer is null!"); return; }
                    
                    if (data.status === 'empty_result') {
                        const thinkingBoxElement = currentActiveResponseContainer.querySelector('.thinking-content-box'); 
                        if (thinkingBoxElement) { // It should have been created by thinking_content
                            const contentWrapper = thinkingBoxElement.querySelector('.thinking-content-wrapper');
                            if (contentWrapper) {
                                thinkingBoxElement.style.display = 'block';
                                contentWrapper.style.display = 'block';
                                const emptyResult = document.createElement('div');
                                emptyResult.className = 'rag-empty-result'; // Ensure this class has styles
                                const queryText = lastUserMessage ? lastUserMessage.replace(/^#查询\s+/i, '') : '';
                                emptyResult.innerHTML = `<i class="fas fa-exclamation-triangle"></i> 知识库中未找到关于"${queryText}"的相关信息`;
                                contentWrapper.appendChild(emptyResult);
                                const toggleIcon = currentActiveResponseContainer.querySelector('.thinking-box-header .thinking-box-toggle i');
                                if(toggleIcon) toggleIcon.className = 'fas fa-chevron-up'; 
                            }
                        }
                    }
                     return;
                }

                if (data.event === "stream_end" || data.event === "error" || data.event === "complete") {
                    console.log("Stream ended or error occurred:", data.event);
                    isProcessingMessage = false;
                    if(sendBtn) sendBtn.disabled = false; 
                    if(typingIndicator) typingIndicator.style.display = 'none'; 
                    
                    if (currentEventSource) {
                        closeEventSource(); 
                    }
                    if (currentActiveResponseContainer) { // Check if it exists before querying
                        const respContentEl = currentActiveResponseContainer.querySelector('.response-content');
                        if (respContentEl) {
                            respContentEl.classList.remove('loading');
                        }
                    }
                    previousFullMessage = ''; 
                    currentCleanedContentForDisplay = ''; // RESET HERE
                    currentActiveResponseContainer = null; // Reset for the next message cycle
                }
            }

            // 新的打字效果函数 - 更高效且避免重复
            function displayWithTypewriter(element, fullTextPortion, isThinkingText = false) {
                if (element.typingTimerId) { 
                    clearTimeout(element.typingTimerId);
                    element.typingTimerId = null;
                }
            
                let textToTypeThisChunk_Cleaned = "";
            
                if (isThinkingText) { 
                    textToTypeThisChunk_Cleaned = fullTextPortion; // Thinking text is typed as is
                    // For thinking text, we append. The element.textContent is already the accumulated prior thinking text.
                    // No clearing of element.textContent here for thinking text.
                } else { // Final AI response
                    let rawNewChunk;
                    if (fullTextPortion.startsWith(previousFullMessage)) {
                        rawNewChunk = fullTextPortion.substring(previousFullMessage.length);
                    } else {
                        // Stream reset or mismatch. We should re-type the whole cleaned `fullTextPortion`.
                        console.warn("Full message mismatch for final response. Retyping entire cleaned content.", { previous: previousFullMessage, new: fullTextPortion });
                        element.textContent = ""; // Clear DOM content
                        currentCleanedContentForDisplay = ""; // Reset accumulator for cleaned content
                        rawNewChunk = fullTextPortion; // Process the whole thing as "new"
                    }
            
                    // Remove 『...』 and 【...】 patterns
                    textToTypeThisChunk_Cleaned = rawNewChunk.replace(/『.*?』/g, '').replace(/【.*?】/g, '');
                    // Clean up resulting empty lines or lines with only whitespace more effectively
                    let lines = textToTypeThisChunk_Cleaned.split('\n');
                    lines = lines.map(line => line.trim() === '' ? '' : line); // Trim lines that become empty
                    textToTypeThisChunk_Cleaned = lines.filter(line => line !== '').join('\n'); // Join non-empty lines

                    // Ensure the element displays the current accumulated cleaned content before typing the new cleaned chunk
                    element.textContent = currentCleanedContentForDisplay;
                }
            
                // console.log("displayWithTypewriter details:", { isThinkingText, fullTextPortion, textToTypeThisChunk_Cleaned, currentCleanedContentForDisplay_beforeChunk: currentCleanedContentForDisplay });

                if (!textToTypeThisChunk_Cleaned && !isThinkingText) {
                    // Even if the cleaned chunk is empty, update previousFullMessage with the raw data.
                    previousFullMessage = fullTextPortion;
                    // console.log("Cleaned new chunk is empty. Raw stream updated.");
                    if (element.classList && fullTextPortion === previousFullMessage) { 
                         element.classList.remove('typing');
                    }
                    return;
                }
            
                let charIndex = 0;
                let currentTextInElement = element.textContent || ""; 

                function typeChar() {
                    if (charIndex < textToTypeThisChunk_Cleaned.length) {
                        currentTextInElement += textToTypeThisChunk_Cleaned.charAt(charIndex); // Append new char
                        element.textContent = currentTextInElement;
                        charIndex++;
                        if (chatContainer) chatContainer.scrollTop = chatContainer.scrollHeight;
                        element.typingTimerId = setTimeout(typeChar, typingSpeed);
                    } else {
                        element.typingTimerId = null;
                        if (!isThinkingText) {
                            previousFullMessage = fullTextPortion; // Update raw tracker
                            currentCleanedContentForDisplay = element.textContent; // Update cleaned accumulator with the final state
                            if (element.classList) element.classList.remove('typing');
                        }
                        // For thinking text, each span is independent.
                    }
                }
                
                if (!isThinkingText && element.classList) { 
                   element.classList.add('typing');
                }
                typeChar();
            }

            // 添加到script标签末尾 - 切换思考框显示/隐藏的函数
            function toggleThinkingBox(thinkingBox, forceCollapse = false) { // thinkingBox is the .thinking-content-box element
                if (!thinkingBox) return;
                const contentWrapper = thinkingBox.querySelector('.thinking-content-wrapper');
                // The toggle button is in the header, which is a sibling of thinkingBox or parent's sibling
                // So, we need to find the header associated with this thinkingBox
                let toggleBtnIcon = null;
                if (thinkingBox.previousElementSibling && thinkingBox.previousElementSibling.classList.contains('thinking-box-header')) {
                    const header = thinkingBox.previousElementSibling;
                    const btn = header.querySelector('.thinking-box-toggle i');
                    if (btn) toggleBtnIcon = btn;
                } else {
                    // Fallback if structure is different or to find it more robustly
                    // This assumes thinkingBox is inside currentActiveResponseContainer
                    if(currentActiveResponseContainer) {
                        const headerInCurrent = currentActiveResponseContainer.querySelector('.thinking-box-header .thinking-box-toggle i');
                        if(headerInCurrent) toggleBtnIcon = headerInCurrent;
                    }
                }
                
                if (!contentWrapper || !toggleBtnIcon) {
                    console.warn("toggleThinkingBox: contentWrapper or toggleBtnIcon not found for", thinkingBox);
                    return;
                }
                
                const isExpanded = contentWrapper.style.display !== 'none';
                
                if (forceCollapse || isExpanded) {
                    contentWrapper.style.display = 'none';
                    toggleBtnIcon.className = 'fas fa-chevron-down';
                } else {
                    contentWrapper.style.display = 'block';
                    toggleBtnIcon.className = 'fas fa-chevron-up';
                }
                
                if (chatContainer) chatContainer.scrollTop = chatContainer.scrollHeight;
            }

            // 添加新函数用于开始显示思考内容 (This is invoked by user action e.g. clicking expand)
            function startThinkingContentDisplay() { 
                if (thinkingDisplayStarted || thinkingContents.length === 0) return;
                
                if (!currentActiveResponseContainer) {
                    console.error("startThinkingContentDisplay: currentActiveResponseContainer is null.");
                    return;
                }
                const thinkingBox = currentActiveResponseContainer.querySelector('.thinking-content-box');
                
                if (!thinkingBox) {
                    console.error("Thinking box (.thinking-content-box) not found to display content.");
                    return;
                }
                const contentWrapper = thinkingBox.querySelector('.thinking-content-wrapper');
                if (!contentWrapper) {
                    console.error("Thinking content wrapper not found within .thinking-content-box.");
                    return;
                }
                
                // This function is now primarily about populating an ALREADY EXPANDED box,
                // or if called programmatically, ensure it's expanded.
                // The toggleThinkingBox function handles the actual display none/block.
                // If this function is called, we assume the box *should* be visible.

                if (contentWrapper.style.display === 'none') { // If hidden, show it
                    toggleThinkingBox(thinkingBox, false); // false means expand if collapsed
                }
                
                if (thinkingDisplayStarted && contentWrapper.children.length > 0 && contentWrapper.children.length === thinkingContents.length) {
                    // Content already displayed, do nothing
                    console.log("startThinkingContentDisplay: Content already seems to be displayed.");
                    return;
                }

                thinkingDisplayStarted = true; // Mark that we've started the process
                contentWrapper.innerHTML = ''; // Clear previous before starting new display
                
                let currentContentIndex = 0;
                let typeNextTimer = null;

                function displayNextChunk() {
                    if (typeNextTimer) clearTimeout(typeNextTimer);

                    if (currentContentIndex >= thinkingContents.length) {
                        thinkingDisplayStarted = false; // Reset for potential re-expansion later if needed
                        return;
                    }

                    const item = thinkingContents[currentContentIndex];
                    const textSpan = document.createElement('span');
                    textSpan.className = item.type === "rag_knowledge" ? 'rag-knowledge typing-text' : 'typing-text';
                    contentWrapper.appendChild(textSpan);
                    
                    // Modify displayWithTypewriter to return a promise or take a callback
                    // For simplicity, let's assume displayWithTypewriter is fast enough for each chunk
                    // or we use a timeout to simulate sequential typing of chunks.
                    displayWithTypewriter(textSpan, item.content, true); 

                    contentWrapper.appendChild(document.createElement('br')); 
                    currentContentIndex++;
                    
                    // Schedule the next chunk. Adjust timing as needed.
                    // A small delay helps ensure one chunk "finishes" visually before the next starts if typewriters are quick.
                    typeNextTimer = setTimeout(displayNextChunk, 50); // Small delay before typing next chunk
                }
                displayNextChunk();
            }
        });

        // 添加一些CSS样式来美化等待消息
        function addWaitingStyles() {
            const styleElement = document.createElement('style');
            styleElement.textContent = `
                .waiting-message {
                    background-color: #f8f9fa;
                    border-left: 4px solid #ffc107;
                    padding: 10px 15px;
                    margin: 10px 0;
                    border-radius: 4px;
                    font-size: 14px;
                    color: #666;
                    animation: pulse 2s infinite;
                }
                
                @keyframes pulse {
                    0% { opacity: 0.7; }
                    50% { opacity: 1; }
                    100% { opacity: 0.7; }
                }
                
                .waiting-message i {
                    margin-right: 8px;
                    color: #ffc107;
                }
            `;
            document.head.appendChild(styleElement);
        }


        // 全局变量，用于存储当前响应的累积内容
        let currentResponseContent = '';

        // 处理SSE事件
        function handleEvent(event) {
            try {
                const data = JSON.parse(event.data);
                console.log('处理事件:', data);
                
                // 处理角色选择事件
                if (data.event === 'role_selected') {
                    // 重置累积内容
                    currentResponseContent = '';
                    
                    // 异步更新角色信息
                    setTimeout(() => {
                        // 更新当前角色信息
                        currentRole = {
                            id: data.role_id || 'unknown',
                            name: data.role_name,
                            system_prompt: data.system_prompt
                        };
                        console.log('角色已选择:', currentRole);
                        
                        // 创建新的响应容器
                        const chatContainer = document.getElementById('chatContainer');
                        const responseContainer = createResponseContainer();
                        chatContainer.appendChild(responseContainer);
                        
                        // 更新角色头像和名称
                        updateResponseAvatar();
                    }, 0);
                    
                    // 主进程继续处理其他事件
                    return;
                }

                // 处理消息内容
                if (data.content) {
                    // 累积内容而不是替换
                    currentResponseContent += data.content;

                    // 更新显示
                    const responseContent = document.querySelector('.response-content');
                    if (responseContent) {
                        // 使用markdown渲染累积的内容
                        const md = window.markdownit({
                            html: true,
                            linkify: true,
                            typographer: true,
                            highlight: function (str, lang) {
                                if (lang && hljs.getLanguage(lang)) {
                                    try {
                                        return hljs.highlight(str, { language: lang }).value;
                                    } catch (__) {}
                                }
                                return ''; // 使用默认的转义
                            }
                        });

                        responseContent.innerHTML = md.render(currentResponseContent);

                        // 如果有代码块，应用语法高亮
                        responseContent.querySelectorAll('pre code').forEach((block) => {
                            hljs.highlightElement(block);
                        });
                        
                        // 移除loading状态
                        responseContent.classList.remove('loading');
                    }

                    // 如果有角色信息，异步更新角色头像和名称
                    if (data.role_name) {
                        setTimeout(() => {
                            if (!currentRole) {
                                currentRole = {
                                    id: data.role_id || 'unknown',
                                    name: data.role_name
                                };
                            } else {
                                currentRole.name = data.role_name;
                                if (data.role_id) {
                                    currentRole.id = data.role_id;
                                }
                            }
                            
                            updateResponseAvatar();
                        }, 0);
                    }
                }

                // 处理其他类型的事件...

            } catch (e) {
                console.error('处理事件时出错:', e, event);
            }
        }

        // 创建响应容器
        function createResponseContainer() {
            // 重置累积内容
            currentResponseContent = '';
            
            const container = document.createElement('div');
            container.className = 'response-container'; // Rely on class for styling
            
            // 创建头像
            const avatar = document.createElement('div');
            avatar.className = 'response-avatar';

            // 使用角色信息设置头像
            if (currentRole && currentRole.name) {
                // 使用角色名称的首字母作为头像文本
                avatar.textContent = currentRole.name.charAt(0);

                // 添加角色名称标签
                const roleLabel = document.createElement('div');
                roleLabel.className = 'role-label';
                roleLabel.textContent = currentRole.name;
                avatar.appendChild(roleLabel);
            } else {
                // 默认头像
                avatar.textContent = 'A';

                // 添加默认角色标签
                const roleLabel = document.createElement('div');
                roleLabel.className = 'role-label';
                roleLabel.textContent = '助手';
                avatar.appendChild(roleLabel);
            }

            // 创建内容区域
            const content = document.createElement('div');
            content.className = 'response-content loading';

            // 添加组件到容器
            container.appendChild(avatar);
            container.appendChild(content);

            return container;
        }

        // 更新响应角色名称和头像
        function updateResponseAvatar() {
            if (!currentRole || !currentRole.name) return;

            // 查找当前响应容器
            const responseContainer = document.getElementById('responseContainer');
            if (responseContainer) {
                // 更新头像文本为角色名首字母
                const avatar = responseContainer.querySelector('.response-avatar');
                if (avatar) {
                    avatar.textContent = currentRole.name.charAt(0);

                    // 查找或创建角色标签
                    let roleLabel = avatar.querySelector('.role-label');
                    if (!roleLabel) {
                        roleLabel = document.createElement('div');
                        roleLabel.className = 'role-label';
                        avatar.appendChild(roleLabel);
                    }

                    // 更新角色名称
                    roleLabel.textContent = currentRole.name;
                }
            }
        }

    </script>
</body>

</html>